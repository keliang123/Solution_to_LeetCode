/*
	爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
	爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 
	每次抽取都是独立的，其结果具有相同的概率。
	当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

	输入：N = 10, K = 1, W = 10
	输出：1.00000
	说明：爱丽丝得到一张卡，然后停止。
	
	输入：N = 6, K = 1, W = 10
	输出：0.60000
	说明：爱丽丝得到一张卡，然后停止。
	在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。

	输入：N = 21, K = 17, W = 10
	输出：0.73278
	
	动态规划思想： dp[i]表示当前点数和是i获胜的概率，因为是从[1 , W]中随机取，所以动态规划转移方程：
			dp[i] = (dp[i+1] + dp[i+2]...+dp[i+W])/W
		最终的结果就是求dp[0]
		而初试条件就是i=K 到i=K+W的值，以为只要点数和大于K就会停止抽牌了。
		
		但当W很大时，很超时，然后变换转移方程就是：
			dp[i] = dp[i + 1] - dp[i + w + 1]/W + dp[i + 1]/W;
		i = K - 1是单独讨论。
		
		
*/

class Solution {
    public double new21Game(int N, int K, int W) {
        if (K == 0 || K + W <= N) return 1.0;
        double[] res = new double[K + W];
        for (int i = K ; i < K + W && i <= N ; i ++) {
            res[i] = 1.0;
        }
        res[K - 1] = 1.0 * Math.min(N - K + 1, W) / W;
        for (int i = K - 2 ; i >= 0 ; i --) {
            res[i] = res[i + 1] + res[i + 1]/W - res[i + 1 + W]/W;
        }
        return res[0];
    }
}

/*
	时间复杂度：O(min(N , K + W)) ,
	空间复杂度：O(K + W)
*/
